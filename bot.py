import os
import logging
import tempfile
import sys
from dotenv import load_dotenv
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
import yt_dlp

# Configuration du logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.DEBUG,
    stream=sys.stdout
)
logger = logging.getLogger(__name__)

# Chargement des variables d'environnement
logger.info("Chargement des variables d'environnement...")
load_dotenv()
TOKEN = os.getenv('TELEGRAM_TOKEN')

logger.info("=== D√âMARRAGE DE L'APPLICATION ===")
logger.info(f"Token trouv√© : {'Oui' if TOKEN else 'Non'}")
if TOKEN:
    logger.info(f"Token (premiers caract√®res) : {TOKEN[:10]}...")

if not TOKEN:
    logger.error("Token Telegram non trouv√© ! V√©rifiez votre fichier .env ou les variables d'environnement Heroku.")
    raise ValueError("Token Telegram non trouv√© !")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /start"""
    logger.info("=== COMMANDE START RECUE ===")
    logger.info(f"Utilisateur : {update.effective_user.id}")
    logger.info(f"Message : {update.message.text}")
    
    try:
        logger.info("Envoi du message de bienvenue...")
        await update.message.reply_text(
            "üëã Bonjour ! Je suis un bot qui peut t√©l√©charger des vid√©os.\n"
            "Envoyez-moi un lien de vid√©o et je la t√©l√©chargerai pour vous."
        )
        logger.info("Message de bienvenue envoy√© avec succ√®s")
    except Exception as e:
        logger.error(f"Erreur lors de la commande start : {str(e)}")
        logger.exception("D√©tails de l'erreur :")
        await update.message.reply_text("‚ùå Une erreur s'est produite. Veuillez r√©essayer.")

async def download_video(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """T√©l√©charge et envoie la vid√©o"""
    user_id = update.effective_user.id
    url = update.message.text
    logger.info(f"=== TENTATIVE DE T√âL√âCHARGEMENT ===")
    logger.info(f"Utilisateur : {user_id}")
    logger.info(f"URL : {url}")
    
    # V√©rification que c'est bien une URL
    if not url.startswith(('http://', 'https://')):
        logger.warning(f"URL invalide re√ßue de l'utilisateur {user_id}: {url}")
        await update.message.reply_text("‚ùå Veuillez envoyer une URL valide.")
        return

    # Message de chargement
    loading_message = await update.message.reply_text("‚è≥ T√©l√©chargement en cours...")

    try:
        # Cr√©ation d'un dossier temporaire
        with tempfile.TemporaryDirectory() as temp_dir:
            logger.info(f"Dossier temporaire cr√©√© : {temp_dir}")
            
            # Configuration de yt-dlp
            ydl_opts = {
                'format': 'best[filesize<50M]',  # Limite la taille √† 50MB
                'outtmpl': os.path.join(temp_dir, '%(title)s.%(ext)s'),
                'quiet': True,
                'no_warnings': True,
                'postprocessors': [{
                    'key': 'FFmpegVideoConvertor',
                    'preferedformat': 'mp4',
                }],
                'postprocessor_args': [
                    '-c:v', 'libx264',
                    '-crf', '28',  # Compression plus agressive
                    '-preset', 'ultrafast',
                    '-c:a', 'aac',
                    '-b:a', '128k'
                ],
            }

            # T√©l√©chargement de la vid√©o
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                logger.info(f"D√©but du t√©l√©chargement pour {url}")
                info = ydl.extract_info(url, download=True)
                video_path = os.path.join(temp_dir, f"{info['title']}.{info['ext']}")
                logger.info(f"Vid√©o t√©l√©charg√©e : {video_path}")

            # Envoi de la vid√©o
            logger.info(f"Envoi de la vid√©o √† l'utilisateur {user_id}")
            
            # V√©rification de la taille du fichier
            file_size = os.path.getsize(video_path)
            if file_size > 50 * 1024 * 1024:  # 50MB en bytes
                await update.message.reply_text("‚ùå La vid√©o est trop grande (plus de 50MB). Veuillez essayer avec une vid√©o plus courte.")
                return
                
            await update.message.reply_video(
                video=open(video_path, 'rb'),
                caption=f"‚úÖ Voici votre vid√©o : {info['title']}"
            )
            logger.info(f"Vid√©o envoy√©e avec succ√®s √† l'utilisateur {user_id}")

    except Exception as e:
        logger.error(f"Erreur lors du t√©l√©chargement pour l'utilisateur {user_id}: {str(e)}")
        logger.exception("D√©tails de l'erreur :")
        await update.message.reply_text("‚ùå Une erreur s'est produite lors du t√©l√©chargement. Veuillez r√©essayer avec un autre lien.")
    finally:
        await loading_message.delete()

def main():
    """Fonction principale"""
    logger.info("=== D√âMARRAGE DU BOT ===")
    
    try:
        # Cr√©ation de l'application
        logger.info("Cr√©ation de l'application...")
        application = Application.builder().token(TOKEN).build()
        logger.info("Application cr√©√©e avec succ√®s")

        # Ajout des handlers
        logger.info("Ajout des handlers...")
        application.add_handler(CommandHandler("start", start))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, download_video))
        logger.info("Handlers ajout√©s avec succ√®s")

        # D√©marrage du bot
        logger.info("D√©marrage du polling...")
        application.run_polling(allowed_updates=Update.ALL_TYPES)
    except Exception as e:
        logger.error(f"Erreur lors du d√©marrage du bot : {str(e)}")
        logger.exception("D√©tails de l'erreur :")
        raise

if __name__ == '__main__':
    main() 